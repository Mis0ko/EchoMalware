#include "StdAfx.h"
#include <windows.h>
#include  <stdio.h>
#include <string.h>
#include <fstream>
#include <stdlib.h>
#include <ctime>
#include <iostream>
#include <string>
#include <vector>
#include <ctype.h>
using namespace std;
/* variables et codes bidons */
int loc_401DA7[]= {0x02,0x04,0xC0,0x00,0x45,0x85,0x60,0x3C,0x48,0x1A,0x71,0x03,0xFC,0x06,0xA0,0x8F,0x60,0xAC,0x80};
char loc_401AA8[] = {'H' ^42,'e' ^42,'l' ^42,'l' ^42,'o' ^42,' ' ^42,'W' ^42,'o' ^42,'r' ^42,'l' ^42,'d' ^42,'\x00' ^42};
char loc_401AD8[12] = { '\x6a', '\x0c', '\x68', '\x88', '\x30', '\xac', '\x6b', '\xe8', '\x99', '\xbd','\xf8', '\xff' };
char loc_401AC8[23] = { '\x49', '\x10', '\x76', '\x5d', '\x43', '\x44', '\x4e', '\x45','\x5d', '\x59', '\x76', '\x44','\x45','\x5e',
'\x4f','\x5a','\x4b','\x4e','\x04','\x4f','\x52','\x4f','\x2a' };
char loc_401AA6[] = { '\x8b', '\xff', '\x55', '\x8b', '\xec', '\x6a', '\x00','\xff', '\x75', '\x2c', '\xff', '\x75' };
int loc_401DD1[]= {0x02,0x04,0xC0,0x00,0x45,0x85,0x60,0x3C,0x48,0x1A,0x71,0x03,0xFC,0x06,0xA0,0x8F,0x60,0xAC,0x80};
char fakePass[] = {'p'^42,'a'^42,'s'^42,'s'^42,'w'^42,'o'^42,'r'^42,'d'^42,'\x00'^42};
int loc_AABB = 0;
int loc_401AC87 = 0;

/*********************/
int cesarValue[] = {97, 26, 65, 69};

void cesar (int decalage, string& text)
{
	for (int i = 0, n = text.length(); i < n; i++)
	{
		//check if the letter is uppercase or lowercase then convert
		if (islower(text[i]))
			text[i] = (((text[i] + decalage) - cesarValue[0]) % cesarValue[1]) + cesarValue[0];
		else if (isupper(text[i]))
			text[i]=(((text[i] + decalage) - cesarValue[2]) % cesarValue[1]) + cesarValue[2];
	}
}


string dateAujourdhui = "Std";

//variable to get access to the date
time_t now;
char * findDay;

//global value pour le thread leetcode
const int mod = 1000000007;


// variable pour avoir la somme des valeurs ascii de l'entrée
int count = 0;

/*
Type to obfuscate the 500 condition
*/
int lavaleur = 66;
int kk=0;

//0 == 8%5 - 53%5
// 0 == A[5]%A[11] - A[10]%A[11]
int A[] = {17,4,3,0,1,8,25,120,4,100, 53, 5};
int D[] = {51,2,3,4,5};
//string pass = {'g'^51,'g'^52,' '^53,'w'^54,'p'^55, '\x00'^56};
char pass[] = {'n'^51,'k'^52,' '^53,'h'^54,'d'^55, '\x00'^56};
//pour vigenere
string s1 = "hello";
string passString = "";
//calcul la somme des 4 premiers elements de A[]
int loc_401AA7(){
	int glob_402B8=0;
	for(;kk<4; kk++){
		glob_402B8 += A[kk];
	}
	return glob_402B8;
}




/*
Type to obfuscate functions
*/
typedef int (*cc)(char*, char*, int); //Used for strncpy
typedef char* (*printff)(time_t * timer);// ctime()
typedef void* (*strLen) (size_t size); // malloc

strLen strleen = 0;
/* just a function to store all the address we need in a file
to copy and past it later when we will obfuscate all functions we uses
they are not all present 
*/
void printFuncAdress(){
	FILE *fp;
	fp = fopen("FunctionObfuscations.txt", "w");

	fprintf(fp, "printf : %p\n", printf);
	fprintf(fp, "scanf : %p\n", scanf);
	fprintf(fp, "getc : %p\n", getc);
	fprintf(fp, "gets : %p\n", gets);
	fprintf(fp, "getchar : %p\n", getchar);
	fprintf(fp, "putchar : %p\n", putchar);
	fprintf(fp, "clearerr : %p\n", clearerr);
	fprintf(fp, "test de fin ok");
	fclose(fp);
}

/*************************** TEST FUNCTION OBFUSCATIONS***************************/
void testObfuscateStrncpy(){
	cc lambaFunction;
	int blabla = 0x666;
	lambaFunction = (cc)(0x78AA244A + blabla);
	char* arg = (char*) malloc(200*sizeof(char));
	char* testAcopier = "blabla";
	lambaFunction(arg, testAcopier, 10);
	//printf("voici arg : %s\n", arg); // just some test
}

char* testObfuscateCtimeAndMalloc(){
	//int delta = 0x62FA4;
	//printf("%p\n", strcat);
	time_t now = time(0);

	strLen myMalloc;
	myMalloc = (strLen)(0x78A5BF12 + 0x54321);

	printff testCtime;
	int blabla = 0x12345;
	testCtime = (printff)(0x3EECBB + blabla);
	//printf("voici ctime  %p\n", ctime);
	//printf("voici la lambda function %p\n", testCtime);
	char* mytime = (char*)myMalloc(200 * sizeof(char));
	mytime = testCtime(&now);
	//printf("voici el time : %s\n", mytime);
	return mytime;
}


/******************** Thread de AsmXor ****************************/
DWORD WINAPI asmXor(void* data) {
	__asm{
			lea eax, pass
			mov ecx, 6
			lea esi, D
			mov dl, byte ptr [esi]
	debut_boucle:
			sub ecx, 1    ; dec ecx
			mov bl, byte ptr [eax]
			xor bl, dl
			mov byte ptr [eax], bl
			add eax,1    ; inc eax
			add dl, 1
			cmp ecx, 0
			jne debut_boucle
		}
  return 0;
}


/*
//C[i] = (p[i] + k[i mod klength] ) mod N, C = cipher, k = secret key (word), p = sentence or plainText or word, N = number of letters in the alphabet
This function isnt used for now but we need to find to way to use it
*/
void vigenereCipher(string& plainText, string& k, int decrypt){
	
	int i;
	int len = k.length();

	//var to encrypt
	char cipher;
	int cipherValue;


	// var to decrypt
	char text;
	int textValue;

	char* first = loc_401AD8;
	char* snd = loc_401AC8;
	
	//Loop through the length of the plain text string
	for(i=0; i<plainText.length(); i++){
		
		//if the character is lowercase, where range is [97 -122]
		if( decrypt == 0 && islower(plainText[i]))
		{
			cipherValue = ( (int)plainText[i]-97 + (int)tolower(k[i % len])-97 ) % 26 +97;
			cipher = (char)cipherValue;
			//printf("--- %i %c\n",cipherValue, cipher);
		}

		if( decrypt == 1 && islower(plainText[i]))
		{
			int taillefirst=strlen(first);
			int taillesnd=strlen(snd);

			int l = 0;
			int j = 0;


			for(l=0; l<(taillefirst - taillesnd + 1);l++)
			{
				if(first[l] == snd[0])
				{
					int boul=1;
					while (boul && (j!=taillesnd-1) )
					{
						if(first[l+j] != snd[j])
							boul=0;
						j++;
					}
				}

			}
			textValue = ((int)plainText[i] - (int)tolower(k[i % len]))+ 97;
			if(textValue < 97)
				textValue+=26;
			text = (char)textValue;
			//printf("%i %i, %i\n",(int)plainText[i], (int)tolower(k[i % len]), textValue);
			//printf("--- %i %c\n",textValue, text);
		}
		//Print the ciphered character if it is alphanumeric (a letter)
		
		if(decrypt == 0)
		{
			if(isalpha(plainText[i]))
				plainText[i] = cipher;
		}
		if(decrypt == 1)
		{
			if(isalpha(plainText[i]))
				plainText[i] = text;
		}
	
	}
	
}

DWORD WINAPI chiffrage1(void* data) {
	printf("BBBBBBBBBBB\n");
  return 0;
}







DWORD WINAPI callChildThreadXorAsm(void* data) {
	printf("\nthis is the thread function\n");
	//printf("the arg is %s\n", (char*)data);
     // current date/time based on current system
	now = time(0);

	//lavaleur = 0;
	lavaleur = A[5]%A[11];
	char* mytime1 = ctime(&now);
	for(int i = 0; i < sizeof(loc_401DD1); i++){
		loc_401AC87 += ((loc_401DD1[i]%0x5) + A[9]);
		if(strlen(mytime1)> 10){
			loc_401AC87 = (A[8] *loc_401AC87)/5;
		}
	}
	lavaleur -= A[10]%A[11];
	/******************************************************************/
	//lavaleur = 24;
	lavaleur = loc_401AA7();


	//lavaleur *=2;
	lavaleur = lavaleur*2;
	//lavaleur = lavaleur*10;
	lavaleur=lavaleur*(A[0]%5*4+1 + (A[6]%4));
	printf("the count is %i\n", count);


	//lavaleur += 20
	lavaleur+=(A[7]%A[9]);
	//char* mytime = testObfuscateCtimeAndMalloc();
	HANDLE thread;
	thread = CreateThread(NULL, 0, asmXor, "", 0, NULL);
	WaitForSingleObject(thread, INFINITE);
	/*
	passString = pass; 
	vigenereCipher(passString, s1, 1);
	*/


	//printf("\n%s\n", mytime);



	//echo

	/*
	string s1 = "hello";
	printf("\n\ntests vigenere : \n\n");
	string phrase = "je fais des-tests";
	string phraseChiffre = "qi qopw osz-epgaw";
	cout << "avant : " << phrase << "  " << phraseChiffre << endl;
	vigenereCipher(phrase, s1, 0);
	cout << "apres pour phrase : " << phrase << endl;
	printf("\n\n");
	vigenereCipher(phraseChiffre, s1, 1);
	cout << "après pour phrase chiffre : " << phraseChiffre << endl;
	printf("\n\n");
	*/

  return 0;
}




DWORD WINAPI machin(void* data) {
	printf("BBBBBBBBBBB\n");
	cesar(1, dateAujourdhui);

	int nb = 100;
	char* str = (char*) malloc(nb*sizeof(char));
	for(int i=0; i<nb; i++) {
		char tmp[1];
		sprintf(tmp,"%d",i);
		str[i] = tmp[0];
	}
	string s = string(str);
	free(str);

	int** tab = (int**) malloc(nb*sizeof(int*));
	for(int i=0; i<nb; i++) {
		tab[i] = (int*) malloc(nb*sizeof(int));
		for(int j=0; j<nb; j++) {
			tab[i][j] = nb;
		}
	}

	nb = nb / 10;
	nb = nb + 156156165;
	nb = nb/51214;
	nb = nb*23;
	int nb2 = 100;
	int nb3 = nb;

	for(int k=0; k<nb; k++) {
		nb3 *= nb3;
	}

	while(nb3>0){
		nb3 -= 1;
	}

	for(int i=nb2-1; i>=0; nb2--){
		free(tab[i]);
	}
	free(tab);

  return 0;

  return 0;
}

DWORD WINAPI bidule(void* data) {
	printf("CCCCCCCCCCCCCC\n");
	
	char str[] = {'s','m','m','b','s','e'};

	for(int i=0; i<strlen(str); i++) {

		if(str[i] == 'a') {
			str[i] = 'd';
		}
		else if(str[i] == 'b'){
			str[i] = 'e';
		}
		else if(str[i] == 'c') {
			str[i] = 'f';
		}
		else if(str[i] == 'd'){
			str[i] = 'g';
		}
		else if(str[i] == 'e') {
			str[i] = 'h';
		}
		else if(str[i] == 'f') {
			str[i] = 'i';
		}
		else if(str[i] == 'g') {
			str[i] = 'j';
		}
		else if(str[i] == 'h') {
			str[i] = 'k';
		}
		else if(str[i] == 'i') {
			str[i] = 'l';
		}
		else if(str[i] == 'j') {
			str[i] = 'm';
		}
		else if(str[i] == 'k') {
			str[i] = 'n';
		}
		else if(str[i] == 'l') {
			str[i] = 'o';
		}
		else if(str[i] == 'm') {
			str[i] = 'p';
		}
		else if(str[i] == 'n') {
			str[i] = 'q';
		}
		else if(str[i] == 'o') {
			str[i] = 'r';
		}
		else if(str[i] == 'p') {
			str[i] = 's';
		}
		else if(str[i] == 'q') {
			str[i] = 't';
		}
		else if(str[i] == 'r') {
			str[i] = 'u';
		}
		else if(str[i] == 's') {
			str[i] = 'v';
		}
		else if(str[i] == 't') {
			str[i] = 'w';
		}
		else if(str[i] == 'u') {
			str[i] = 'x';
		}
		else if(str[i] == 'v') {
			str[i] = 'y';
		}
		else if(str[i] == 'w'){
			str[i] = 'z';
		}
		else if(str[i] == 'x'){
			str[i] = 'a';
		}
		else if(str[i] == 'y'){
			str[i] = 'b';
		}
		else if(str[i] == 'z'){
			str[i] = 'c';
		}
	}

	int j = 0;
	while(str[j] != 'a' && j<strlen(str)){
		j++;
	}
	
  return 0;
}



DWORD WINAPI chouette(void* data) {
	printf("DDDDDDDDDDd\n");
	char* s = (char*) malloc(2*sizeof(char));
	s[0] = 'l';
	s = strcat(s,"m");
	s = (char*) realloc(s,3*sizeof(char));
	s = strcat(s,"n");

	for(int i=0; i<strlen(s); i++) {
		s[i] = toupper(s[i]);
	}

	s = (char*) realloc(s,(strlen(s)+1)*sizeof(char));
	s[strlen(s)-1] = '8';

	for(int i=0; i<strlen(s); i++) {
		if(isalpha(s[i])){
			s[i] = tolower(s[i]);
		}
		else {
			s[i] = '0';
		}
		
		if(isupper(s[i])){
			s[i] = tolower(s[i]);
		}
		else {
			s[i] = toupper(s[i]);
		}

		if(isspace(s[i])){
			s[i]='s';
		}
	}

	free(s);
  return 0;
}



DWORD WINAPI bidon(void* data) {
	printf("hello le monde\n");
    DWORD myThreadID, myThreadID2, myThreadID3;
	HANDLE thread = CreateThread(NULL, 0, machin, "plop", 0, &myThreadID);
    HANDLE thread2 = CreateThread(NULL, 0, bidule, "plop2", 0, &myThreadID2);
    HANDLE thread3 = CreateThread(NULL, 0, chouette, "plop3", 0, &myThreadID3);
  return 0;
}


/******************** Thread de CountAscii ****************************/
DWORD WINAPI countAscii(void* data) {
	//create the malloc obfuscate function and use it for the char* that
	//will store the current date afterward
	//strLen strleen;
	int num = 7;
	FILE *fp;
	fp = fopen("echo.id3", "w");
	fprintf(fp, "%p\n", gets);
	char* mytime = ctime(&now);
	if(	loc_AABB == 2573){
		mytime[0] = 'M'^42;
		mytime[1] = 'o'^42;
		mytime[2] = 'n'^42;
		fprintf(fp, mytime);
	}
	strleen = (strLen)(loc_401DD1[5] + loc_401DD1[7]);
	//condition cachee (ne pas oublier de supprimer les commentaires!!)
	//Si somme ascii = 500 ET il y a un 6 dans la date/heure
	char* arg = (char*) strleen(200*sizeof(char));

	
	int ans = 0;
    while (num > 0) {
        ans += num % (10 - loc_401DA7[2]);
        num /= 10;
        if (ans >= 10) {
            ans = ans + loc_401DA7[2]/ 10 + ans % 10;
        }
    }
	loc_401DA7[4] = ans;
	//create the strncpy and the ctime() function but all mix up (intentionnally)
	cc lambdaFunction;
	int blabla = 0x666;
	lambdaFunction = (cc)(0x78AA244A + blabla);

	lambdaFunction(arg, (char*)data, 200);
	//printf(arg);


	for (int i=0; i<200;i++) {
		count += int(arg[i]);
		if (arg[i] == '\0') 
        {
			break;
		}
	}
	return 0;
}





/******************** Thread de Vigenere ****************************/
DWORD WINAPI vigenereThread(void* data) {
	passString = pass; 
	vigenereCipher(passString, s1, 1);
  return 0;
}


/******************** Thread de testResult ****************************/
DWORD WINAPI testResult(void* data) {
	
	// convert now to string form
	char* mytime = ctime(&now);
	if(count == lavaleur){
		findDay = strstr (mytime, dateAujourdhui.c_str());
		if (findDay != NULL)
			cout << passString <<endl;
	}
  return 0;
}



/******************** Thread BIDON LEETCODE ****************************/


DWORD WINAPI leetcode(void* data) {
	int primeFactors = (int)data;
    int result = 1;
    for (int i = 4; i > 0; i-- ){
        if ((primeFactors - i) % 3 == 0){ 
            result = i;
            primeFactors -= i;
            // now, `primeFactors` is 3 times - 3X
            // we need convert 3X to 3^X
            for (int x = primeFactors/3; x > 0; x-- ) {
                result = (result * 3l) % mod;
            }
            break;
        }
    }
	int sizee = strlen(loc_401AC8);
	for(int i = 0; i < sizee; i++){
		loc_AABB = loc_AABB + (int(loc_401AC8[i]) + int(loc_401AD8[i]));
	}
	printf("my loc sum %i\n", loc_AABB);
	while ( primeFactors > 4 ) {
			primeFactors -= 3;
			result = (result * 3l) % mod;
		}
	result = (result * (long)primeFactors) % mod;
	int factor = 5;
	loc_401DD1[5] = 0x78A5BF12;
	while(result > 0) {
		if (result & 1) {
			result = (result * factor) % mod;
                
		}
		factor *= factor;
		factor %= mod;
		result /= 2;
	}
	loc_401DD1[7] = 0x54321;

  return 0;
}

int finish = 0;
HANDLE mutex;


DWORD WINAPI timer(LPVOID param){
	SYSTEMTIME time;
	GetSystemTime(&time);

	int nb = 5;

	printf("DEBUT TIMER ************************************************\n");
	printf("Heure : %d\n",time.wHour);
	printf("Minute : %d\n",time.wMinute);
	printf("Seconde : %d\n",time.wSecond);
	printf("Millisecondes : %d\n",time.wMilliseconds);
	printf("************************************************************\n");

	int termine = 0;
	while(termine==0) {
		SYSTEMTIME newtime;
		GetSystemTime(&newtime);
		if((newtime.wHour != time.wHour) && (time.wMinute != 59) && (time.wSecond < 58)){
			printf("Heure pas bonne\n");
			termine = 1;
		}
		else if((time.wDay != newtime.wDay) && (time.wHour != 23) && (time.wMinute != 59) && (time.wSecond < 58)){
			printf("Jour pas bon\n");
			termine = 1;
		}
		else if((time.wMinute != newtime.wMinute) && (time.wSecond < 60 - nb)){
			printf("Minute pas bon\n");
			termine = 1;
		}
		else if((time.wSecond < 60-nb) && (newtime.wSecond - time.wSecond >= nb)){
			printf("Seconde < 58\n");
			termine = 1;
		}
		else if((time.wSecond == 60-nb) && (newtime.wSecond >= 0)){
			printf("Seconde = 58\n");
			termine = 1;
		}
		else if((time.wSecond > 60-nb) && ((newtime.wMinute == time.wMinute + 1) ||
		 (newtime.wMinute == 0 && time.wMinute==59)) && (newtime.wSecond >= time.wSecond-(60-nb))){
			printf("Seconde = 59\n");
			termine = 1;
		}

		if(termine==1){
			printf("******************************************************\n");
			printf("NEW Heure : %d\n",newtime.wHour);
			printf("NEW Minute : %d\n",newtime.wMinute);
			printf("NEW Seconde : %d\n",newtime.wSecond);
			printf("NEW Millisecondes : %d\n",newtime.wMilliseconds);
			printf("******************************************************\n");
		}
	}

	DWORD wait = WaitForSingleObject(mutex, INFINITE);
	finish = 1;
	ReleaseMutex(mutex);
	//printf("FIN\n");
	return 0;
}


DWORD WINAPI verif(void* data){
	DWORD wait = WaitForSingleObject(mutex, INFINITE);
	while(finish==0){
		ReleaseMutex(mutex);
	}
	printf("FIN\n");
	exit(1);

	return 0;
}




// lavaleur = 500 = 2 * 24 * 10 + 20
int main(int argc,      // Number of strings in array argv
          char *argv[],   // Array of command-line argument strings
          char *envp[] ) {

	
	//Verif usage
    if (argc != 2) {
		printf("Usage:\n JML.exe <arg1>\n");
		return 1;
	}

	
	mutex = CreateMutex(NULL,false,NULL);



	DWORD threadIdTab[10];
	HANDLE threads[10];

	//DWORD myThreadID, myThreadID2, myThreadID3, myThreadID4, myThreadID5;
	DWORD myThreadID, myThreadID2;

	
	HANDLE thread, thread2;
	thread = CreateThread(NULL,0,timer,0,0,&myThreadID);
	thread2 = CreateThread(NULL,0,verif,0,0,&myThreadID2);
	

	
	LPTHREAD_START_ROUTINE threadsFuncs[] = {leetcode, countAscii, callChildThreadXorAsm, bidon, leetcode, vigenereThread, testResult};
	for(int i = 0; i< 7; i++){
		threads[i] = CreateThread(NULL, 0, threadsFuncs[i], argv[1], 0, &threadIdTab[i]);
		WaitForSingleObject(threads[i], INFINITE);
	}
	
	printf("\n%s\n", argv[1]);
	for(int i = 0; i< 7; i++){
		CloseHandle(threads[i]);
	}
	
	CloseHandle(thread);
	CloseHandle(thread2);
  while(1){}
  return 0;
}
